# coding=utf-8
import unittest

"""338. Counting Bits
https://leetcode.com/problems/counting-bits/description/

<p>Given a non negative integer number <b>num</b>. For every numbers <b>i</b> in the range <b>0 &le; i &le; num</b> calculate the number of 1's in their binary representation and return them as an array.
</p>
<p>
<b>Example:</b></br>
For <code>num = 5</code> you should return <code>[0,1,1,2,1,2]</code>.
</p>
<p>
<b>Follow up:</b>
<ul>
<li>It is very easy to come up with a solution with run time <b>O(n*sizeof(integer))</b>. But can you do it in linear time <b>O(n)</b> /possibly in a single pass?</li>
<li>Space complexity should be <b>O(n)</b>.</li>
<li>Can you do it like a boss? Do it without using any builtin function like <b>__builtin_popcount</b>  in c++ or in any other language.</li>
</ul>
</p>

<p><b>Credits:</b><br />Special thanks to <a href="https://leetcode.com/discuss/user/syedee">@ syedee </a> for adding this problem and creating all test cases.</p>
Similar Questions:
  Number of 1 Bits (number-of-1-bits)
"""


class Solution(object):
    def countBits(self, num):
        """
        :type num: int
        :rtype: List[int]
        """
        

    def test(self):
        pass


if __name__ == "__main__":
    unittest.main()
