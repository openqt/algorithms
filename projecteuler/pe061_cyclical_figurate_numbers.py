#!/usr/bin/env python
# coding=utf-8
"""
Cyclical figurate numbers
Problem 61

Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are
all figurate (polygonal) numbers and are generated by the following formulae:

    Triangle	 	P3,n=n(n+1)/2	 	1, 3, 6, 10, 15, ...
    Square	 	    P4,n=n^2	 	    1, 4, 9, 16, 25, ...
    Pentagonal	 	P5,n=n(3n−1)/2	 	1, 5, 12, 22, 35, ...
    Hexagonal	 	P6,n=n(2n−1)	 	1, 6, 15, 28, 45, ...
    Heptagonal	 	P7,n=n(5n−3)/2	 	1, 7, 18, 34, 55, ...
    Octagonal	 	P8,n=n(3n−2)	 	1, 8, 21, 40, 65, ...

The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three
interesting properties.

    1. The set is cyclic, in that the last two digits of each number is the
    first two digits of the next number (including the last number with the
    first).

    2. Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and
    pentagonal (P5,44=2882), is represented by a different number in the set.

    3. This is the only set of 4-digit numbers with this property.

Find the sum of the only ordered set of six cyclic 4-digit numbers for which
each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and
octagonal, is represented by a different number in the set.
"""
from __future__ import print_function
from pe012_highly_divisible_triangular_number import triangle_number
from pe044_pentagon_numbers import pentagonal_number
from pe045_triangular_pentagonal_and_hexagonal import hexagonal_number


def square_number(start=1, count=-1):
    """square sequence

    :param count:
    :return:
    """
    while count != 0:
        square_number.func_dict['n'] = start

        count -= 1
        yield start ** 2
        start += 1


def heptagonal_number(start=1, count=-1):
    """heptagonal sequence

    :param start:
    :param count:
    :return:
    """
    while count != 0:
        heptagonal_number.func_dict['n'] = start

        count -= 1
        yield start * (5 * start - 3) // 2
        start += 1


def octagonal_number(start=1, count=-1):
    """octagonal sequence

    :param start:
    :param count:
    :return:
    """
    while count != 0:
        octagonal_number.func_dict['n'] = start

        count -= 1
        yield start * (3 * start - 2)
        start += 1


def _dfs(n, caches, mask=None, val=None):
    """search by iteration and yield result"""

    def tails():  # iterate through 2nd half by 1st half is n
        for i in range(len(caches)):
            if mask[i] and n in caches[i]:
                mask[i] = False
                for j in caches[i][n]:
                    yield j
                mask[i] = True

    # initial mask and return value cache
    if val is None:
        val = [n]
    if mask is None:
        mask = [True] * len(caches)

    if any(mask):  # not check all P functions
        for i in tails():
            val.append(i)
            for j in _dfs(i, caches, mask, val):
                yield j
            val.pop()
    else:  # found one !
        if val[0] == val[-1]:
            yield val


if __name__ == '__main__':
    def scope(it):
        """helper function get two half set for all 4 digits"""
        m = {}
        for i in it():
            if i > 10000:
                break
            if i > 1000:
                a, b = divmod(i, 100)
                if a > 10 and b > 10:
                    m.setdefault(a, []).append(b)
        return m

    caches = [
        scope(triangle_number),
        scope(square_number),
        scope(pentagonal_number),
        scope(hexagonal_number),
        scope(heptagonal_number),
        scope(octagonal_number),
    ]

    for i in caches[-1]:
        for n in _dfs(i, caches):
            print(n)
            # 28684
            print(sum(n[j - 1] * 100 + n[j] for j in range(1, len(n))))
